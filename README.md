# Project Report: LEGO Mindstorms EV3 Robot Navigation

Our project involved using the LEGO Mindstorms EV3 to create a robot to navigate and avoid obstacles in a given grid. We built our robot based on the LEGO handbook driving base configuration guidelines. We initially were able to set it up; however, the robot was unable to turn on, and we later found we had a battery issue and got a replacement from the TA. We ran code from the sample projects to see basic functionality and began from there.

We had some reservations as to what function calls to use for motion but decided to use `run_angle` as opposed to `run` or `run_time` as it was pretty straightforward to calculate the distance the robot would move based on the revolution of the wheels. The distance the robot moved was based on the circumference of the robotâ€™s wheels, which was obtained from its diameter. As for turns, we knew tight pivots on the spot would be achieved by rotating one wheel forward and the other backward at the same speed. As we could not utilize any of the prebuilt functions for turning, we experimented with wheel revolutions that yielded close to 90 degrees. Also, because of the imperfections of the motors, we got different turn angles for 90-degree left and right turns.

As we could drive and make turns, we worked on following some hard-coded test paths (an array of tuples) and executing turns based on the coordinate values. If we had the same Y values as the previous point but different X values, we would make a right or left turn. As for the opposite, we would either move forward or make two turns to move backward. After running tests, we observed that some wrong paths were taken and realized that the orientation of the robot had to be included. The robot had to know where it was facing to reflect the appropriate turns. That being said, we then mapped out what turns should be taken given a change in the X coordinates and also given a change in the Y coordinates and updated the orientation accordingly. For example, if the robot was facing north and made a right turn, its orientation would now be East. After making that implementation, we were able to follow a hard-coded path correctly.

Next was using a path-finding algorithm. We used A* due to how simple the algorithm was to implement for this project and its ability to find the best possible path (shortest path) from the origin location to the destination. A* requires the calculation of the f cost, and the formula for it is `f(n) = g(n) + h(n)` where `g(n)` represents the distance from the starting location and `h(n)` represents the distance from the goal. Additionally, `h(n)` represents the heuristics of the algorithm, and the heuristic that we used is the overall distance between a location and the goal location. Using this algorithm, we are guaranteed to find a path if one exists. However, the biggest drawback is that it takes a while to compute the path on the EV3 device due to memory limitations, but on a modern computer, the computation is quite quick. Fortunately, this issue is not a big deal due to the changes that we added to the algorithm, which improved the runtime of the algorithm.

We aimed at making tweaks to our robot as it was drifting quite a bit while moving, which accumulated and put it off the mark of the goal. To aid with driving and better turns, a gyroscope was added, and this made our robot more steady. While testing in the lab, we found that the tape on the floor again caused some deviations in our turns and motion, and we again made some compensations for that.

Overall, our robot can now be placed at any arbitrary location, and if given the coordinates of the obstacles on the course and the location of the goal, the robot will find a path to the goal without running into any obstacles. We have taken into account some of the drifts and deviations that cause the robot to move away from the goal location, which decreased the chances of the robot missing the goal point by some additive errors.
